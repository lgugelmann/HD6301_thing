#!/usr/bin/python3

"""This script reads a .bdf font file and generates a C header file with a
bitmap of the first 128 ASCII characters. The non-printable ones are replaced by
the space character. The font is stored in a linear array in rows of 1024 bytes,
with each byte representing 8 pixels. The first row is the top row of all 128
characters, the second row is the second row of all 128 characters, and so on.
"""

FONT_FILE_PATH = '../dependencies/uni_vga/u_vga16.bdf'
OUTPUT_FILE_PATH = 'font.h'
BYTES_PER_LINE = 12
NUM_CHARS = 128
CHAR_HEIGHT = 15
CHAR_WIDTH = 8
HEADER="""// Automatically generated by fontgen.py, do not edit.

#ifndef EIGHT_BIT_FONT_H
#define EIGHT_BIT_FONT_H

const unsigned char font[] = {
"""

def reverse_bits(byte):
    "Reverse the bits in a byte."
    byte = ((byte & 0xF0) >> 4) | ((byte & 0x0F) << 4)
    byte = ((byte & 0xCC) >> 2) | ((byte & 0x33) << 2)
    byte = ((byte & 0xAA) >> 1) | ((byte & 0x55) << 1)
    return byte

def parse_char(f):
    "Parse a character from the .bdf file."
    encoding = int(next(f).split()[1])
    if encoding < 32 or encoding > 126:
        return None, None
    while not next(f).startswith('BITMAP'):
        pass
    bitmap = [reverse_bits(int(next(f).strip(), 16)) for _ in range(CHAR_HEIGHT)]
    return encoding, bitmap

def read_font_file(file_path):
    "Read a .bdf font file and return a list of bitmaps for the first 128 ASCII characters."
    font = [None] * NUM_CHARS
    with open(file_path, 'r', encoding='utf8') as f:
        for line in f:
            if line.startswith('STARTCHAR'):
                encoding, bitmap = parse_char(f)
                if encoding is not None:
                    font[encoding] = bitmap
    return font

def write_font_bytes(f, font):
    "Write the font bitmaps to the output file f."
    font_data = []
    for y in range(CHAR_HEIGHT):
        for i in range(128):
            bitmap = font[i] if font[i] else font[ord(' ')]
            font_data.append(bitmap[y] if bitmap else 0)

    bytes_written = 0
    for byte in font_data:
        if bytes_written % BYTES_PER_LINE == 0:
            f.write(' ')
        f.write(f' 0x{byte:02X},')
        if bytes_written % BYTES_PER_LINE == BYTES_PER_LINE - 1:
            f.write('\n')
        bytes_written += 1
    return bytes_written

if __name__ == '__main__':
    font = read_font_file(FONT_FILE_PATH)
    with open(OUTPUT_FILE_PATH, 'w', encoding='utf8') as header:
        header.write(HEADER)
        BYTES_WRITTEN = write_font_bytes(header, font)
        assert BYTES_WRITTEN == 128 * CHAR_HEIGHT
        header.write('};\n\n')
        header.write(f'const unsigned int font_len = {BYTES_WRITTEN};\n\n')
        header.write('#endif  // EIGHT_BIT_FONT_H\n')
